<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mandelbrot Research: GPGPU Implementation</title>
<style>
  :root{ --bg:#050505; --panel:#0f1115; --text:#c9d1d9; --accent:#58a6ff; --border:rgba(255,255,255,0.08); }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:'Segoe UI',Inter,sans-serif; overflow:hidden;}
  .app{display:flex; height:100vh; width:100vw;}
  
  /* Sidebar Styling */
  .sidebar{width:300px; min-width:300px; background:var(--panel); border-right:1px solid var(--border); display:flex; flex-direction:column; padding:16px; box-sizing:border-box; z-index:10; box-shadow: 4px 0 24px rgba(0,0,0,0.5);}
  .sidebar h1{ font-size:14px; margin:0 0 16px 0; color:#fff; letter-spacing:0.5px; text-transform: uppercase; opacity:0.8; border-bottom: 1px solid var(--border); padding-bottom: 8px;}
  
  /* UI Groups */
  .group{ margin-bottom:16px; border-bottom:1px solid var(--border); padding-bottom:16px; }
  .group:last-child{ border:0; }
  label{ display:block; font-size:11px; color:#8b949e; margin-bottom:6px; font-weight:600; text-transform:uppercase; }
  
  /* Inputs & Buttons - Unified Style */
  select, button, input[type=number], input[type=range] { 
    background:#161b22; color:var(--text); border:1px solid var(--border); 
    padding:6px 8px; border-radius:6px; outline:none; font-size:13px; 
    transition:0.2s; box-sizing: border-box;
  }
  
  select, button { width:100%; margin-bottom:4px; }
  select:hover, button:hover, input:hover { border-color:var(--accent); }
  select:focus, input:focus { border-color:var(--accent); }
  
  button{ background:#21262d; cursor:pointer; font-weight:600; }
  button.primary{ background:var(--accent); color:#000; border:none; }
  
  /* Row Layout for Side-by-Side Controls */
  .row{ display:flex; gap:8px; align-items:center; width: 100%; }
  
  /* Specific override for the Iteration inputs to look unified */
  input[type=range] { flex: 1; padding: 0; cursor: pointer; height: 30px; }
  input[type=number] { width: 70px; text-align: center; font-family: monospace; }

  /* Viewport & Canvas */
  .viewport{ flex:1; position:relative; overflow:hidden; cursor:crosshair; }
  canvas{ display:block; width:100%; height:100%; }
  
  /* Overlay / Debug Panel */
  .overlay{ position:absolute; bottom:20px; right:20px; text-align:right; pointer-events:none; }
  .coord-box{ background:rgba(0,0,0,0.7); padding:8px 12px; border-radius:6px; font-family:monospace; font-size:12px; color:#8b949e; backdrop-filter:blur(4px); border: 1px solid var(--border); }
  
  /* Loading Indicator */
  .loading-line{ position:absolute; top:0; left:0; width:100%; height:3px; background:transparent; }
  .loading-line i{ display:block; height:100%; width:0%; background:var(--accent); transition: width 0.2s ease-out; box-shadow:0 0 10px var(--accent); }
  
  /* Presets Grid */
  .presets{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
  .preset-btn{ font-size:11px; padding:6px; background:#161b22; text-align:left; }
</style>
</head>
<body>

<div class="app">
  <div class="sidebar">
    <h1>Математичне ядро</h1>

    <div class="group">
      <label>Метод побудови</label>
      <select id="ui_build">
        <option value="0">Класичний (Escape Time)</option>
        <option value="1">Оцінка відстані (Milnor)</option>
        <option value="2">Орбітальна пастка (Geometric)</option>
      </select>
    </div>

    <div class="group" id="color_group"> 
      <label>Відображення кольору</label>
      <select id="ui_color">
        <option value="0">Дискретне (смугасте)</option>
        <option value="1" selected>Плавне (ренормалізоване)</option>
        <option value="2">Гістограмна еквалізація</option>
      </select>
    </div>

    <div class="group">
      <label>Ліміт ітерацій</label>
      <div class="row">
        <input type="range" id="ui_iter" min="10" max="4096" step="1" value="500">
        <input type="number" id="ui_iter_num" min="10" max="4096" value="500">
      </div>
    </div>

    <div class="group">
      <label>Навігація та вивід</label>
      <div class="row">
        <button id="btn_reset">Скинути вигляд</button>
        <button id="btn_save" class="primary">Зберегти PNG</button>
      </div>
    </div>

    <div class="group" style="flex:1">
      <label>Бенчмарки (Пресети)</label>
      <div class="presets">
        <button class="preset-btn" onclick="loadPreset('seahorse')">Долина морського коника</button>
        <button class="preset-btn" onclick="loadPreset('elephant')">Долина слона</button>
        <button class="preset-btn" onclick="loadPreset('spiral')">Глибока спіраль</button>
        <button class="preset-btn" onclick="loadPreset('mini')">Мініброт</button>
      </div>
    </div>

    <div style="font-size:10px; color:#444; margin-top:auto">
      Точність Float32 у WebGL.<br>Реалізована строга математика.
    </div>
  </div>

  <div class="viewport">
    <div class="loading-line"><i id="progress"></i></div>
    <canvas id="glcanvas"></canvas>
    <div class="overlay">
      <div class="coord-box" id="debug_panel" style="min-width: 220px; font-family: monospace; line-height: 1.5;">
        <div style="color: #00ff00; border-bottom: 1px solid #444; margin-bottom: 5px; font-weight: bold;">МАТЕМАТИЧНИЙ СТАН</div>
        <div>Re: <span id="val_re">-0.75000000</span></div>
        <div>Im: <span id="val_im">0.00000000</span></div>
        <div>ΔRe (Точність): <span id="val_prec">0</span></div>
        <div>Рівень зуму: <span id="val_zoom">1.0e+0</span></div>
        
        <div style="color: #00ff00; border-bottom: 1px solid #444; margin-top: 10px; margin-bottom: 5px; font-weight: bold;">ПРОДУКТИВНІСТЬ</div>
        <div>Час кадру: <span id="val_time">0</span> ms</div>
        <div>Пропускна здатність: <span id="val_thru">0</span> M-Iter/s</div>
        
        <div id="prec_warning" style="color: #ff4444; display: none; font-weight: bold; margin-top: 5px;">
          ⚠️ ЛІМІТ ТОЧНОСТІ ДОСЯГНУТО
        </div>
      </div>
    </div>
  </div>
</div>


<script id="vs" type="x-shader/x-vertex">
  attribute vec2 position;
  void main() { gl_Position = vec4(position, 0.0, 1.0); }
</script>

<script id="fs" type="x-shader/x-fragment">
  precision highp float;

  // Uniforms strictly controlling the math & render state
  uniform vec2 u_res;       // Viewport resolution
  uniform vec2 u_center;    // Complex plane center
  uniform float u_scale;    // Scale: Pixels per Unit (Zoom level)
  uniform int u_iter;       // Max iterations
  
  // Modes
  uniform int u_build_mode; // 0=Classic, 1=DE, 2=Trap
  uniform int u_color_mode; // 0=Discrete, 1=Smooth, 2=Hist
  
  // Histogram Data
  uniform sampler2D u_lut;  // Lookup table for histogram mode
  uniform int u_pass;       // 0=Render, 1=Collect Data

  // --- MATH CORE ---
  // Complex multiplication
  vec2 cmul(vec2 a, vec2 b) { 
    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); 
  }

  struct FractalResult {
    float i;        // Iteration count
    float smooth_i; // Renormalized iteration value
    float dist;     // Milnor distance estimation
    float trap;     // Orbit trap metric (min distance to origin)
    bool inside;    // Set membership flag
  };

  FractalResult compute(vec2 c) {
    vec2 z = vec2(0.0);
    vec2 dz = vec2(0.0); // Derivative for DE: dz' = 2*z*dz + 1
    float minDot = 1e30; // Store squared distances to avoid repeated sqrt

    // Bailout threshold increased for better smooth coloring and DE precision
    const float B = 256.0; 
    const float B2 = B * B;
    const float lnB = log(B);

    float iter_count = float(u_iter);
    bool escaped = false;
    
    // Reduced upper loop bound (safer for WebGL compilers)
    for (int i=0; i<4096; i++) {
      if (i >= u_iter) break;

      // 1. Calculate Derivative (Chain Rule) BEFORE updating Z
      dz = 2.0 * cmul(z, dz) + vec2(1.0, 0.0);

      // 2. Complex Iteration: Z = Z^2 + C
      z = cmul(z, z) + c;
      
      float d = dot(z, z);
      minDot = min(minDot, d); // Update orbit trap metric

      if (d > B2) {
        escaped = true;
        iter_count = float(i);
        break;
      }
      iter_count = float(i);
    }

    float sm_i = iter_count;
    float dist = 0.0;

    float trapVal = sqrt(minDot); // Final trap distance

    if (escaped) {
      // Smooth Coloring Correction (Renormalization) with overflow protection
      float log_z = 0.5 * log(dot(z, z)); // ln|z|
      float nu = 0.0;
      if (log_z > lnB * 1.000001) {
        nu = log(log_z / lnB) / log(2.0);
      }
      sm_i = iter_count + 1.0 - nu;

      // Distance Estimation Formula (Milnor)
      float r = length(z);
      float dr = length(dz);
      if (dr > 1e-8) {
        dist = 0.5 * r * log(max(r, 1e-6)) / dr;
      } else {
        dist = 1e20;
      }
    } else {
      sm_i = float(u_iter);
    }

    return FractalResult(iter_count, sm_i, dist, trapVal, !escaped);
  }

  // --- COLORING CORE ---
  vec3 palette(float t) {
    vec3 a = vec3(0.5);
    vec3 b = vec3(0.5);
    vec3 c = vec3(1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
  }

  void main() {
    // 1. Map Pixel to Complex Plane
    vec2 screen_pos = gl_FragCoord.xy;
    vec2 c = (screen_pos - 0.5 * u_res) / u_scale + u_center;

    // 2. Compute Physics
    FractalResult res = compute(c);

    // 3. Data Collection Pass (for Histogram)
    if (u_pass == 1) {
      float norm = clamp(res.i / float(u_iter), 0.0, 1.0);
      gl_FragColor = vec4(norm, 0.0, 0.0, 1.0);
      return;
    }

    // 4. Render Pass
    if (res.inside) {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
      return;
    }

    vec3 color = vec3(0.0);

    // Mode-dependent Coloring Logic
    if (u_build_mode == 0) {
      float t = 0.0;
      if (u_color_mode == 0) { // Discrete
        t = floor(res.i) / 50.0;
      } else if (u_color_mode == 1) { // Smooth
        t = res.smooth_i / 50.0;
      } else { // Histogram
        float idx = clamp(res.i / float(u_iter), 0.0, 1.0);
        t = texture2D(u_lut, vec2(idx, 0.5)).r * 3.0; 
      }
      color = palette(t);
    }
    else if (u_build_mode == 1) { // Distance Estimation
      float dist_px = res.dist * u_scale;
      float border_intensity = clamp(dist_px, 0.0, 1.0);
      color = vec3(pow(border_intensity, 0.2)); 
      color *= vec3(0.9, 0.95, 1.0); 
    }
    else if (u_build_mode == 2) { // Orbit Trap
      float t = res.trap; 
      color = vec3(exp(-2.0 * t));
      color = mix(color, palette(t * 4.0), 0.5);
    }

    gl_FragColor = vec4(color, 1.0);
  }
</script>

<script>
/**
 * Mandelbrot GPGPU Visualizer
 * Core: WebGL/GLSL
 * Features: Distance Estimation, Orbit Traps, Histogram Equalization
 */
const App = {
  gl: null,
  prog: null,
  canvas: null,
  
  state: {
    center: { x: -0.75, y: 0.0 },
    scale: 300.0,
    iter: 500,
    buildMode: 0,
    colorMode: 1,
    resolution: { w: 800, h: 600 },
    lastFrameTime: 0 
  },

  lutTexture: null,
  renderTimer: null,
  needsHighQuality: false,
  loc: null,
  
  init() {
    this.canvas = document.getElementById('glcanvas');
    this.gl = this.canvas.getContext('webgl', { preserveDrawingBuffer: true }) || this.canvas.getContext('experimental-webgl');
    
    if (!this.gl) { alert("WebGL not supported"); return; }

    const gl = this.gl;

    const highFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
    this.supportsHighp = !!(highFloat && highFloat.precision > 0);

    if (!this.supportsHighp) {
      console.warn("Fragment highp not supported — switching to safe mode.");
      this.state.iter = Math.min(this.state.iter, 512);
      if (this.state.buildMode === 1) this.state.buildMode = 0;
      this.state.scale = Math.min(this.state.scale, 1e5);
      this.isFallbackPrecision = true;
    } else {
      this.isFallbackPrecision = false;
    }
    
    this.initShaders();
    this.initBuffers();
    this.initTexture();
    this.bindEvents();
    this.resize();
    
    this.renderLow();
    this.scheduleHigh();
  },

  initShaders() {
    const gl = this.gl;
    const vsSrc = document.getElementById('vs').text;
    const fsSrc = document.getElementById('fs').text;
    
    const vs = this.compile(gl.VERTEX_SHADER, vsSrc);
    const fs = this.compile(gl.FRAGMENT_SHADER, fsSrc);
    
    this.prog = gl.createProgram();
    gl.attachShader(this.prog, vs);
    gl.attachShader(this.prog, fs);
    gl.linkProgram(this.prog);
    
    if (!gl.getProgramParameter(this.prog, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(this.prog));
    }
    gl.useProgram(this.prog);

    this.loc = {
      position: gl.getAttribLocation(this.prog, "position"),
      u_res: gl.getUniformLocation(this.prog, "u_res"),
      u_center: gl.getUniformLocation(this.prog, "u_center"),
      u_scale: gl.getUniformLocation(this.prog, "u_scale"),
      u_iter: gl.getUniformLocation(this.prog, "u_iter"),
      u_build_mode: gl.getUniformLocation(this.prog, "u_build_mode"),
      u_color_mode: gl.getUniformLocation(this.prog, "u_color_mode"),
      u_lut: gl.getUniformLocation(this.prog, "u_lut"),
      u_pass: gl.getUniformLocation(this.prog, "u_pass")
    };

    gl.deleteShader(vs);
    gl.deleteShader(fs);
  },

  compile(type, src) {
    const s = this.gl.createShader(type);
    this.gl.shaderSource(s, src);
    this.gl.compileShader(s);
    if (!this.gl.getShaderParameter(s, this.gl.COMPILE_STATUS)) {
      console.error(this.gl.getShaderInfoLog(s));
    }
    return s;
  },

  initBuffers() {
    const gl = this.gl;
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
    
    const loc = this.loc.position;
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
  },

  initTexture() {
    const gl = this.gl;
    this.lutTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.lutTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  },

  // --- RENDER PIPELINE ---
  renderLow() {
    document.getElementById('progress').style.width = '0%';
    this.draw(false); 
  },

  scheduleHigh() {
    clearTimeout(this.renderTimer);
    document.getElementById('progress').style.width = '30%';
    
    this.renderTimer = setTimeout(() => {
      // If Histogram mode is on, we need a compute pass first
      if (this.state.colorMode == 2 && this.state.buildMode == 0) {
        this.computeHistogram();
      }
      this.draw(true);
      document.getElementById('progress').style.width = '100%';
      setTimeout(() => document.getElementById('progress').style.width = '0%', 200);
    }, 250); // Debounce high-quality render
  },

  computeHistogram() {
    const gl = this.gl;
    const w = 200, h = 150; // Low res sample is enough for stats
    
    gl.uniform2f(this.loc.u_res, w, h);
    gl.uniform2f(this.loc.u_center, this.state.center.x, this.state.center.y);
    gl.uniform1f(this.loc.u_scale, this.state.scale);
    gl.uniform1i(this.loc.u_iter, this.state.iter);
    gl.uniform1i(this.loc.u_build_mode, this.state.buildMode);
    gl.uniform1i(this.loc.u_color_mode, this.state.colorMode);

    gl.uniform1i(this.loc.u_pass, 1); // Set pass to data-collect
    gl.viewport(0, 0, w, h);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // Read pixels (blocking operation)
    const pixels = new Uint8Array(w * h * 4);
    gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

    // Build stats
    const bins = new Uint32Array(256);
    let total = 0;
    for (let i = 0; i < pixels.length; i += 4) {
      if (pixels[i+3] > 0) {
        bins[pixels[i]]++;
        total++;
      }
    }

    // CDF Equalization
    const cdf = new Uint8Array(256 * 4);
    let sum = 0;
    for (let i = 0; i < 256; i++) {
      sum += bins[i];
      const val = total > 0 ? Math.floor((sum / total) * 255) : 0;
      cdf[i*4] = val;
      cdf[i*4+1] = val;
      cdf[i*4+2] = val;
      cdf[i*4+3] = 255;
    }

    gl.bindTexture(gl.TEXTURE_2D, this.lutTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, cdf);

    gl.uniform1i(this.loc.u_pass, 0); // Reset pass
  },

  draw(highQuality) {
    const gl = this.gl;
    const t0 = performance.now(); // 1. Start profiling

    gl.uniform1i(this.loc.u_pass, 0);
    gl.uniform2f(this.loc.u_res, this.canvas.width, this.canvas.height);
    gl.uniform2f(this.loc.u_center, this.state.center.x, this.state.center.y);
    gl.uniform1f(this.loc.u_scale, this.state.scale);
    gl.uniform1i(this.loc.u_iter, this.state.iter);
    gl.uniform1i(this.loc.u_build_mode, this.state.buildMode);
    gl.uniform1i(this.loc.u_color_mode, this.state.colorMode);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.lutTexture);
    gl.uniform1i(this.loc.u_lut, 0);

    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    
    // 2. Measure execution time and update stats
    this.state.lastFrameTime = performance.now() - t0;
    this.updateUI(); 
  },

  updateUI() {
    // 1. Coordinates & Zoom
    document.getElementById('val_re').textContent = this.state.center.x.toFixed(8);
    document.getElementById('val_im').textContent = this.state.center.y.toFixed(8);
    document.getElementById('val_zoom').textContent = this.state.scale.toExponential(2);

    // 2. Precision Calculation (Delta Re)
    // Formula: Width in units / Width in pixels
    const precision = (this.canvas.width / this.state.scale) / this.canvas.width; 
    document.getElementById('val_prec').textContent = precision.toExponential(2);

    // Float32 artifact threshold check (10^-7)
    document.getElementById('prec_warning').style.display = (precision < 1e-7) ? 'block' : 'none';

    // 3. Performance Metrics
    const ms = this.state.lastFrameTime;
    document.getElementById('val_time').textContent = ms.toFixed(1);

    const totalPixels = this.canvas.width * this.canvas.height;
    const mIters = (totalPixels * this.state.iter) / 1_000_000;
    const throughput = ms > 0 ? (mIters / (ms / 1000)) : 0;
    document.getElementById('val_thru').textContent = Math.round(throughput);
  },

  resize() {
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.parentElement.getBoundingClientRect();
    this.canvas.width = rect.width * dpr;
    this.canvas.height = rect.height * dpr;
    this.state.resolution = { w: this.canvas.width, h: this.canvas.height };
    this.scheduleHigh();
  },

  // --- EVENTS ---
  bindEvents() {
    const on = (id, ev, fn) => {
      const el = document.getElementById(id);
      if (el) el.addEventListener(ev, fn);
    };

    const iterRange = document.getElementById('ui_iter');
    const iterNum = document.getElementById('ui_iter_num');
    const colorGroup = document.getElementById('color_group');

    // 1. Mode selection and context-aware UI
    on('ui_build', 'change', (e) => { 
      const mode = parseInt(e.target.value);
      this.state.buildMode = mode; 
      
      // Context-aware UI logic: Hide color options for specific math models
      if (colorGroup) {
        colorGroup.style.display = (mode === 0) ? 'block' : 'none';
      }
      this.scheduleHigh(); 
    });

    on('ui_color', 'change', (e) => { 
      this.state.colorMode = parseInt(e.target.value); 
      this.scheduleHigh(); 
    });

    // 2. Iteration synchronization (Slider)
    if (iterRange) {
      iterRange.addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        this.state.iter = val;
        if (iterNum) iterNum.value = val;
        this.renderLow(); 
        this.scheduleHigh(); 
      });
    }

    // 3. Iteration synchronization (Manual input)
    if (iterNum) {
      iterNum.addEventListener('change', (e) => {
        let val = parseInt(e.target.value);
        if (isNaN(val)) val = 500;
        // Mathematical constraint (precision limit)
        val = Math.max(10, Math.min(val, 4096)); 
        e.target.value = val;
        this.state.iter = val;
        if (iterRange) iterRange.value = val;
        this.renderLow(); 
        this.scheduleHigh();
      });
    }
    
    // 4. Action buttons and system events
    on('btn_reset', 'click', () => { 
      this.state.center = {x:-0.75, y:0}; 
      this.state.scale = 300; 
      if (iterRange) iterRange.value = 500;
      if (iterNum) iterNum.value = 500;
      this.state.iter = 500;
      
      const buildEl = document.getElementById('ui_build');
      if (buildEl) buildEl.value = "0";
      this.state.buildMode = 0;
      if (colorGroup) colorGroup.style.display = 'block';
      
      this.scheduleHigh(); 
    });

    on('btn_save', 'click', () => {
      const link = document.createElement('a');
      link.download = 'fractal.png';
      link.href = this.canvas.toDataURL();
      link.click();
    });

    window.addEventListener('resize', () => this.resize());

    // --- Interaction & Rendering Control ---
    let isDrag = false;
    let lastX = 0, lastY = 0;
    let pendingRAF = false;

    this.canvas.addEventListener('mousedown', e => { 
        isDrag = true; 
        lastX = e.clientX; 
        lastY = e.clientY; 
    });
    
    window.addEventListener('mouseup', () => { 
        isDrag = false; 
        if(this.needsHighQuality) this.scheduleHigh(); 
    });
    
    this.canvas.addEventListener('mousemove', e => {
      if (!isDrag) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      
      const dpr = window.devicePixelRatio || 1;
      this.state.center.x -= (dx * dpr) / this.state.scale;
      this.state.center.y += (dy * dpr) / this.state.scale;
      
      if (!pendingRAF) {
        pendingRAF = true;
        requestAnimationFrame(() => {
          this.renderLow();
          pendingRAF = false;
        });
      }
      this.needsHighQuality = true;
    });

    this.canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const rect = this.canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const mx = (e.clientX - rect.left) * dpr;
      const my = (e.clientY - rect.top) * dpr;
      const glMy = this.canvas.height - my;

      const wx = (mx - 0.5 * this.canvas.width) / this.state.scale + this.state.center.x;
      const wy = (glMy - 0.5 * this.canvas.height) / this.state.scale + this.state.center.y;

      const sensitivity = 0.0015;
      const factor = Math.exp(-e.deltaY * sensitivity);
      this.state.scale *= factor;

      this.state.center.x = wx - (mx - 0.5 * this.canvas.width) / this.state.scale;
      this.state.center.y = wy - (glMy - 0.5 * this.canvas.height) / this.state.scale;

      this.renderLow();
      this.scheduleHigh();
    }, {passive: false});

    // Initial UI state synchronization
    const initialBuild = document.getElementById('ui_build');
    if (initialBuild && colorGroup) {
        colorGroup.style.display = (initialBuild.value === "0") ? 'block' : 'none';
    }
  }
};

window.loadPreset = function(name) {
  const p = {
    'seahorse': { x: -0.748, y: 0.1, s: 3000 },
    'elephant': { x: 0.26, y: -0.002, s: 8000 },
    'spiral': { x: -0.770322, y: -0.113217, s: 8e5 },
    'mini': { x: -1.76, y: 0.0, s: 5000 }
  }[name];
  if(p) {
    App.state.center.x = p.x;
    App.state.center.y = p.y;
    App.state.scale = p.s;
    App.scheduleHigh();
  }
};

window.onload = () => App.init();

</script>
</body>
</html>